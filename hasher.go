package passwordhasher

import (
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"

	"golang.org/x/crypto/argon2"
)

// ErrInvalidHash indicates the stored hash cannot be parsed.
var ErrInvalidHash = errors.New("invalid password hash")

// ErrPasswordMismatch indicates password verification failed.
var ErrPasswordMismatch = errors.New("password mismatch")

// Default Argon2id parameters matching auth-service configuration
// These values provide a good balance between security and performance
const (
	DefaultMemorySize    uint32 = 65536 // 64 MiB in KB
	DefaultIterations    uint32 = 3     // Time cost
	DefaultParallelism   uint8  = 2     // Number of threads
	DefaultKeyLength     uint32 = 32    // Output hash length in bytes
	DefaultSaltLength           = 16    // Salt length in bytes
	DefaultArgon2Version        = 19    // Argon2 version 1.3
)

// Hasher wraps Argon2id hashing with configurable parameters.
// All BengoBox services should use this hasher to ensure password compatibility.
type Hasher struct {
	memorySize  uint32
	iterations  uint32
	parallelism uint8
	keyLength   uint32
	saltLength  int
}

// NewHasher creates a new Hasher with default Argon2id parameters.
// Default parameters: m=65536, t=3, p=2, keylen=32
// These match auth-service configuration for cross-service compatibility.
func NewHasher() *Hasher {
	return &Hasher{
		memorySize:  DefaultMemorySize,
		iterations:  DefaultIterations,
		parallelism: DefaultParallelism,
		keyLength:   DefaultKeyLength,
		saltLength:  DefaultSaltLength,
	}
}

// NewCustomHasher creates a Hasher with custom Argon2id parameters.
// Use this when auth-service configuration changes.
func NewCustomHasher(memorySize, iterations uint32, parallelism uint8, keyLength uint32) *Hasher {
	return &Hasher{
		memorySize:  memorySize,
		iterations:  iterations,
		parallelism: parallelism,
		keyLength:   keyLength,
		saltLength:  DefaultSaltLength,
	}
}

// Hash creates a new Argon2id hash for the supplied plain text password.
// Returns formatted hash: $argon2id$v=19$m=65536,t=3,p=2$<base64-salt>$<base64-hash>
// This format is compatible with the PHC string format and auth-service.
func (h *Hasher) Hash(password string) (string, error) {
	if password == "" {
		return "", errors.New("password cannot be empty")
	}

	// Generate random salt
	salt := make([]byte, h.saltLength)
	if _, err := rand.Read(salt); err != nil {
		return "", fmt.Errorf("generate salt: %w", err)
	}

	// Generate hash using Argon2id
	hash := argon2.IDKey(
		[]byte(password),
		salt,
		h.iterations,
		h.memorySize,
		h.parallelism,
		h.keyLength,
	)

	// Encode to base64 without padding (RFC 4648 base64url)
	b64Salt := base64.RawStdEncoding.EncodeToString(salt)
	b64Hash := base64.RawStdEncoding.EncodeToString(hash)

	// Format: $argon2id$v=19$m=65536,t=3,p=2$<salt>$<hash>
	formatted := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
		DefaultArgon2Version,
		h.memorySize,
		h.iterations,
		h.parallelism,
		b64Salt,
		b64Hash,
	)

	return formatted, nil
}

// Verify verifies that the specified password matches the stored hash.
// Compatible with hashes generated by this library and auth-service.
// Uses constant-time comparison to prevent timing attacks.
func (h *Hasher) Verify(password string, hashedPassword string) error {
	if password == "" {
		return errors.New("password cannot be empty")
	}

	if hashedPassword == "" {
		return errors.New("hashed password cannot be empty")
	}

	// Parse the hash to extract parameters and components
	params, salt, expectedHash, err := parseHash(hashedPassword)
	if err != nil {
		return err
	}

	// Generate hash with extracted parameters
	calculatedHash := argon2.IDKey(
		[]byte(password),
		salt,
		params.iterations,
		params.memorySize,
		params.parallelism,
		uint32(len(expectedHash)),
	)

	// Constant-time comparison to prevent timing attacks
	if subtle.ConstantTimeCompare(calculatedHash, expectedHash) == 1 {
		return nil
	}

	return ErrPasswordMismatch
}

// argon2Params holds Argon2id parameters extracted from hash string.
type argon2Params struct {
	memorySize  uint32
	iterations  uint32
	parallelism uint8
}

// parseHash parses an Argon2id hash string and extracts parameters, salt, and hash.
// Expected format: $argon2id$v=19$m=65536,t=3,p=2$<base64-salt>$<base64-hash>
func parseHash(hash string) (*argon2Params, []byte, []byte, error) {
	parts := strings.Split(hash, "$")
	if len(parts) != 6 {
		return nil, nil, nil, fmt.Errorf("%w: expected 6 parts, got %d", ErrInvalidHash, len(parts))
	}

	// Verify algorithm
	if parts[1] != "argon2id" {
		return nil, nil, nil, fmt.Errorf("%w: not argon2id", ErrInvalidHash)
	}

	// Verify version
	var version int
	if _, err := fmt.Sscanf(parts[2], "v=%d", &version); err != nil {
		return nil, nil, nil, fmt.Errorf("%w: invalid version format", ErrInvalidHash)
	}
	if version != DefaultArgon2Version {
		return nil, nil, nil, fmt.Errorf("%w: unsupported version %d", ErrInvalidHash, version)
	}

	// Parse parameters: m=65536,t=3,p=2
	var memorySize, iterations uint32
	var parallelism uint8
	if _, err := fmt.Sscanf(parts[3], "m=%d,t=%d,p=%d", &memorySize, &iterations, &parallelism); err != nil {
		return nil, nil, nil, fmt.Errorf("%w: invalid parameter format", ErrInvalidHash)
	}

	// Decode salt (base64 without padding)
	salt, err := base64.RawStdEncoding.DecodeString(parts[4])
	if err != nil {
		return nil, nil, nil, fmt.Errorf("%w: invalid salt encoding: %v", ErrInvalidHash, err)
	}

	// Decode hash (base64 without padding)
	hashBytes, err := base64.RawStdEncoding.DecodeString(parts[5])
	if err != nil {
		return nil, nil, nil, fmt.Errorf("%w: invalid hash encoding: %v", ErrInvalidHash, err)
	}

	params := &argon2Params{
		memorySize:  memorySize,
		iterations:  iterations,
		parallelism: parallelism,
	}

	return params, salt, hashBytes, nil
}

// HashWithSalt generates an Argon2id hash using a provided salt.
// This is useful for testing or when you need deterministic hashes.
// In production, use Hash() which generates a random salt.
func (h *Hasher) HashWithSalt(password string, salt []byte) (string, error) {
	if password == "" {
		return "", errors.New("password cannot be empty")
	}

	if len(salt) != h.saltLength {
		return "", fmt.Errorf("salt must be %d bytes", h.saltLength)
	}

	hash := argon2.IDKey(
		[]byte(password),
		salt,
		h.iterations,
		h.memorySize,
		h.parallelism,
		h.keyLength,
	)

	b64Salt := base64.RawStdEncoding.EncodeToString(salt)
	b64Hash := base64.RawStdEncoding.EncodeToString(hash)

	formatted := fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
		DefaultArgon2Version,
		h.memorySize,
		h.iterations,
		h.parallelism,
		b64Salt,
		b64Hash,
	)

	return formatted, nil
}
